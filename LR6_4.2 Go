package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	// Переменные:
	// n, m — размеры прямоугольника
	// t — доступное количество плиток
	var n, m, t int64

	// Использую буферизованный ввод
	in := bufio.NewReader(os.Stdin)

	fmt.Println("Введите n, m, t:")
	if _, err := fmt.Fscan(in, &n, &m, &t); err != nil {
		return
	}

	// Левая и правая границы бинарного поиска
	// Максимально возможная ширина дорожки — половина меньшей стороны
	var l int64 = 0
	var r int64 = min(n, m) / 2

	var ans int64 = 0

	// Бинарный поиск по ответу
	for l <= r {
		// Беру середину диапазона
		k := l + (r-l)/2

		// Количество плиток считается как:
		// полная площадь минус внутренняя площадь
		// S = n*m - (n - 2k)*(m - 2k)
		// После упрощения получаем:
		// S = 2*k*(n + m - 2*k)
		tilesNeeded := 2 * k * (n + m - 2*k)

		// Если плиток хватает — пробуем увеличить ширину
		if tilesNeeded <= t {
			ans = k
			l = k + 1
		} else {
			// Иначе уменьшаем диапазон поиска
			r = k - 1
		}
	}

	// Вывожу максимальную возможную ширину дорожки
	fmt.Println(ans)
}

// Функция для нахождения минимума из двух чисел
func min(a, b int64) int64 {
	if a < b {
		return a
	}
	return b
}
