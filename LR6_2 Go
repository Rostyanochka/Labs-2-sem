package main

import (
	"bufio"
	"encoding/hex"
	"fmt"
	"os"
	"strings"
)

// Константы AES
const (
	Nk = 4  // Размер ключа в словах (128 бит = 4 слова)
	Nb = 4  // Размер блока в словах (128 бит = 4 слова)
	Nr = 10 // Количество раундов для AES-128
)

// S-бокс для AES
var sBox = [256]byte{
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
}

// Обратный S-бокс
var invSBox = [256]byte{
	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,
}

// Rcon значения для расширения ключа
var rcon = [11]byte{0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36}

// State представляет матрицу состояния AES (4x4 байта)
type State [4][4]byte

// PrintHex печатает состояние в hex формате
func (s *State) PrintHex(label string) {
	fmt.Printf("%s:\n", label)
	for i := 0; i < 4; i++ {
		fmt.Print("  ")
		for j := 0; j < 4; j++ {
			fmt.Printf("%02x ", s[i][j])
		}
		fmt.Println()
	}
}

// ExpandKey расширяет ключ AES-128
func ExpandKey(key []byte) []byte {
	expandedKey := make([]byte, (Nr+1)*Nb*4)

	// Копируем исходный ключ
	copy(expandedKey[:16], key)

	bytesGenerated := 16
	rconIter := 1
	var temp [4]byte

	for bytesGenerated < 176 {
		// Копируем последние 4 байта
		copy(temp[:], expandedKey[bytesGenerated-4:bytesGenerated])

		if bytesGenerated%16 == 0 {
			// Циклический сдвиг влево
			t := temp[0]
			temp[0] = temp[1]
			temp[1] = temp[2]
			temp[2] = temp[3]
			temp[3] = t

			// Применяем S-бокс
			for i := 0; i < 4; i++ {
				temp[i] = sBox[temp[i]]
			}

			// Применяем Rcon
			temp[0] ^= rcon[rconIter]
			rconIter++
		}

		// XOR с предыдущими 16 байтами
		for i := 0; i < 4; i++ {
			expandedKey[bytesGenerated] = expandedKey[bytesGenerated-16] ^ temp[i]
			bytesGenerated++
		}
	}

	return expandedKey
}

// PrintKeySchedule печатает расписание ключей
func PrintKeySchedule(expandedKey []byte) {
	fmt.Println("Key Schedule (hex):")
	for i := 0; i < len(expandedKey); {
		fmt.Printf("round %d:\n", i/16)
		for j := 0; j < 4; j++ {
			fmt.Print("  ")
			for k := 0; k < 4 && i < len(expandedKey); k++ {
				fmt.Printf("%02x ", expandedKey[i])
				i++
			}
			fmt.Println()
		}
	}
	fmt.Println()
}

// SubBytes применяет S-бокс к состоянию
func (s *State) SubBytes() {
	for i := 0; i < 4; i++ {
		for j := 0; j < 4; j++ {
			s[i][j] = sBox[s[i][j]]
		}
	}
}

// InvSubBytes применяет обратный S-бокс
func (s *State) InvSubBytes() {
	for i := 0; i < 4; i++ {
		for j := 0; j < 4; j++ {
			s[i][j] = invSBox[s[i][j]]
		}
	}
}

// ShiftRows выполняет сдвиг строк
func (s *State) ShiftRows() {
	// Первая строка без сдвига

	// Вторая строка: сдвиг на 1
	temp := s[1][0]
	s[1][0] = s[1][1]
	s[1][1] = s[1][2]
	s[1][2] = s[1][3]
	s[1][3] = temp

	// Третья строка: сдвиг на 2
	temp = s[2][0]
	temp2 := s[2][1]
	s[2][0] = s[2][2]
	s[2][1] = s[2][3]
	s[2][2] = temp
	s[2][3] = temp2

	// Четвертая строка: сдвиг на 3
	temp = s[3][3]
	s[3][3] = s[3][2]
	s[3][2] = s[3][1]
	s[3][1] = s[3][0]
	s[3][0] = temp
}

// InvShiftRows обратный сдвиг строк
func (s *State) InvShiftRows() {
	// Первая строка без сдвига

	// Вторая строка: обратный сдвиг на 1
	temp := s[1][3]
	s[1][3] = s[1][2]
	s[1][2] = s[1][1]
	s[1][1] = s[1][0]
	s[1][0] = temp

	// Третья строка: обратный сдвиг на 2
	temp = s[2][0]
	s[2][0] = s[2][2]
	s[2][2] = temp
	temp = s[2][1]
	s[2][1] = s[2][3]
	s[2][3] = temp

	// Четвертая строка: обратный сдвиг на 3
	temp = s[3][0]
	s[3][0] = s[3][1]
	s[3][1] = s[3][2]
	s[3][2] = s[3][3]
	s[3][3] = temp
}

// gmul выполняет умножение в поле GF(2^8)
func gmul(a, b byte) byte {
	var p byte = 0
	for i := 0; i < 8; i++ {
		if (b & 1) != 0 {
			p ^= a
		}
		hiBitSet := (a & 0x80) != 0
		a <<= 1
		if hiBitSet {
			a ^= 0x1b
		}
		b >>= 1
	}
	return p
}

// MixColumns перемешивает столбцы
func (s *State) MixColumns() {
	for i := 0; i < 4; i++ {
		a0 := s[0][i]
		a1 := s[1][i]
		a2 := s[2][i]
		a3 := s[3][i]

		s[0][i] = gmul(0x02, a0) ^ gmul(0x03, a1) ^ a2 ^ a3
		s[1][i] = a0 ^ gmul(0x02, a1) ^ gmul(0x03, a2) ^ a3
		s[2][i] = a0 ^ a1 ^ gmul(0x02, a2) ^ gmul(0x03, a3)
		s[3][i] = gmul(0x03, a0) ^ a1 ^ a2 ^ gmul(0x02, a3)
	}
}

// InvMixColumns обратное перемешивание столбцов
func (s *State) InvMixColumns() {
	for i := 0; i < 4; i++ {
		a0 := s[0][i]
		a1 := s[1][i]
		a2 := s[2][i]
		a3 := s[3][i]

		s[0][i] = gmul(0x0e, a0) ^ gmul(0x0b, a1) ^ gmul(0x0d, a2) ^ gmul(0x09, a3)
		s[1][i] = gmul(0x09, a0) ^ gmul(0x0e, a1) ^ gmul(0x0b, a2) ^ gmul(0x0d, a3)
		s[2][i] = gmul(0x0d, a0) ^ gmul(0x09, a1) ^ gmul(0x0e, a2) ^ gmul(0x0b, a3)
		s[3][i] = gmul(0x0b, a0) ^ gmul(0x0d, a1) ^ gmul(0x09, a2) ^ gmul(0x0e, a3)
	}
}

// AddRoundKey применяет раундовый ключ
func (s *State) AddRoundKey(roundKey []byte, round int) {
	for i := 0; i < 4; i++ {
		for j := 0; j < 4; j++ {
			s[j][i] ^= roundKey[round*16+i*4+j]
		}
	}
}

// EncryptBlock шифрует один блок AES
func EncryptBlock(input []byte, expandedKey []byte) []byte {
	var state State

	// Заполняем состояние по столбцам
	for i := 0; i < 16; i++ {
		state[i%4][i/4] = input[i]
	}

	// Начальное сложение с ключом
	state.AddRoundKey(expandedKey, 0)

	// Основные раунды
	for round := 1; round < 10; round++ {
		state.SubBytes()
		state.ShiftRows()
		state.MixColumns()
		state.AddRoundKey(expandedKey, round)
	}

	// Финальный раунд (без MixColumns)
	state.SubBytes()
	state.ShiftRows()
	state.AddRoundKey(expandedKey, 10)

	// Собираем результат
	output := make([]byte, 16)
	for i := 0; i < 16; i++ {
		output[i] = state[i%4][i/4]
	}

	return output
}

// DecryptBlock расшифровывает один блок AES
func DecryptBlock(input []byte, expandedKey []byte) []byte {
	var state State

	// Заполняем состояние по столбцам
	for i := 0; i < 16; i++ {
		state[i%4][i/4] = input[i]
	}

	// Начальное сложение с ключом (последний раунд)
	state.AddRoundKey(expandedKey, 10)

	// Основные раунды в обратном порядке
	for round := 9; round >= 1; round-- {
		state.InvShiftRows()
		state.InvSubBytes()
		state.AddRoundKey(expandedKey, round)
		state.InvMixColumns()
	}

	// Финальный раунд
	state.InvShiftRows()
	state.InvSubBytes()
	state.AddRoundKey(expandedKey, 0)

	// Собираем результат
	output := make([]byte, 16)
	for i := 0; i < 16; i++ {
		output[i] = state[i%4][i/4]
	}

	return output
}

// OFBEncrypt шифрует в режиме OFB
func OFBEncrypt(input []byte, expandedKey []byte, iv []byte) []byte {
	output := make([]byte, len(input))
	prev := make([]byte, 16)
	copy(prev, iv)

	blocks := len(input) / 16

	for b := 0; b < blocks; b++ {
		// Шифруем текущий вектор для получения keystream
		keystream := EncryptBlock(prev, expandedKey)

		// XOR с входными данными
		for i := 0; i < 16; i++ {
			if b*16+i < len(input) {
				output[b*16+i] = input[b*16+i] ^ keystream[i]
			}
		}

		// Обновляем вектор для следующего блока
		copy(prev, keystream)
	}

	return output
}

// OFBDecrypt расшифровывает в режиме OFB (аналогично шифрованию)
func OFBDecrypt(input []byte, expandedKey []byte, iv []byte) []byte {
	// В режиме OFB расшифрование идентично шифрованию
	return OFBEncrypt(input, expandedKey, iv)
}

// GenerateRandomKey генерирует "псевдослучайный" ключ для онлайн-тестирования
func GenerateRandomKey() []byte {
	key := make([]byte, 16)
	// Детерминированная генерация для онлайн-тестирования
	for i := 0; i < 16; i++ {
		key[i] = byte((i*17 + 23) % 256)
	}

	// Преобразуем в печатаемые символы
	const chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
	for i := 0; i < 16; i++ {
		key[i] = chars[int(key[i])%len(chars)]
	}

	return key
}

// GenerateRandomIV генерирует "псевдослучайный" IV для онлайн-тестирования
func GenerateRandomIV() []byte {
	iv := make([]byte, 16)
	// Детерминированная генерация для онлайн-тестирования
	for i := 0; i < 16; i++ {
		iv[i] = byte((i*13 + 7) % 256)
	}
	return iv
}

// PadPKCS7 добавляет PKCS7 padding
func PadPKCS7(data []byte, blockSize int) []byte {
	padding := blockSize - len(data)%blockSize
	if padding == 0 {
		padding = blockSize
	}
	padded := make([]byte, len(data)+padding)
	copy(padded, data)
	for i := len(data); i < len(padded); i++ {
		padded[i] = byte(padding)
	}
	return padded
}

// UnpadPKCS7 удаляет PKCS7 padding
func UnpadPKCS7(data []byte) []byte {
	if len(data) == 0 {
		return data
	}
	padding := int(data[len(data)-1])
	if padding > len(data) || padding == 0 {
		return data
	}
	// Проверяем, что весь padding корректен
	for i := len(data) - padding; i < len(data); i++ {
		if int(data[i]) != padding {
			return data
		}
	}
	return data[:len(data)-padding]
}

func main() {
	reader := bufio.NewReader(os.Stdin)

	// Ввод текста
	fmt.Println("Введите текст для шифрования:")
	input, _ := reader.ReadString('\n')
	input = strings.TrimSpace(input)
	inputBytes := []byte(input)

	// Дополняем до кратного 16 байтам
	inputBytes = PadPKCS7(inputBytes, 16)

	// Генерация ключа
	key := GenerateRandomKey()
	fmt.Printf("Сгенерированный ключ: %s\n", string(key))
	fmt.Printf("Ключ (hex): %s\n", hex.EncodeToString(key))

	// Расширяем ключ
	expandedKey := ExpandKey(key)
	PrintKeySchedule(expandedKey)

	// Генерация IV
	iv := GenerateRandomIV()
	fmt.Printf("IV (hex): %s\n", hex.EncodeToString(iv))

	// Шифрование в режиме OFB
	fmt.Println("\nРежим OFB:")
	fmt.Println("Шифрование...")
	ciphertext := OFBEncrypt(inputBytes, expandedKey, iv)
	fmt.Printf("Зашифрованный текст (hex): %s\n", hex.EncodeToString(ciphertext))

	// Расшифрование
	fmt.Println("\nРасшифрование...")
	decrypted := OFBDecrypt(ciphertext, expandedKey, iv)
	decrypted = UnpadPKCS7(decrypted)
	fmt.Printf("Расшифрованный текст: %s\n", string(decrypted))

	// Тестирование ECB режима (опционально)
	fmt.Println("\n--- Тестирование ECB режима ---")
	if len(inputBytes) >= 16 {
		testBlock := inputBytes[:16]
		fmt.Printf("Тестовый блок (hex): %s\n", hex.EncodeToString(testBlock))

		encryptedBlock := EncryptBlock(testBlock, expandedKey)
		fmt.Printf("Зашифрованный блок (hex): %s\n", hex.EncodeToString(encryptedBlock))

		decryptedBlock := DecryptBlock(encryptedBlock, expandedKey)
		fmt.Printf("Расшифрованный блок (hex): %s\n", hex.EncodeToString(decryptedBlock))
		fmt.Printf("Расшифрованный текст: %s\n", string(decryptedBlock))
	}

	// Проверка целостности
	if string(decrypted) == input {
		fmt.Println("\n✓ Шифрование/расшифрование выполнено успешно!")
	} else {
		fmt.Println("\n✗ Ошибка в шифровании/расшифровании")
	}
}
